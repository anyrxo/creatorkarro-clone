#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// TRUE REDDIT CHAOS - Captured from real conversations
// No templates, just pure chaotic human authenticity

const redditChaosPatterns = {
  // PURE CHAOS - Single word/phrase reactions
  oneWordWonders: [
    "Linear",
    "MongoDB tbh", 
    "ultrathink",
    "This.",
    "GODDAMN IT JIN-YIANG!!!!!",
    "Underrated comment",
    "So, wait. Yours made mistakes.",
    "You're absolutely right.",
    "Can just have another MS with a single interface IMongoToPostgresConverter",
    "Should've used MongoDB tbh. This isn't webscale.",
    "Haha. Why complicate this? Store everything locally in excel. Super easy",
    "But.. no supabase? You'll never make a billion dollars.",
    "Wanna buy my crash course? 100$ for a detailed prompt and a life winning strategy.",
    "Basically me.",
    "Dude. WTF. Don't ruin this for the rest of us."
  ],

  // TECHNICAL CHAOS - Absurd technical specificity
  technicalAbsurdity: [
    "You'll need 847 npm dependencies, each one critical for displaying a checkbox",
    "PostgreSQL read replicas across 12 availability zones", 
    "OAuth2 with JWT tokens that expire every 30 seconds for security",
    "a blockchain-based task completion verification system that mints an NFT every time you check something off",
    "processing over 60,000 transactions a minute",
    "GraphQL federation with Apollo Server",
    "6 redis clusters with Datadog and Sentry monitoring",
    "47 different APIs to add a single todo item",
    "machine learning pipeline that uses TensorFlow to predict whether you'll actually complete your tasks"
  ],

  // FRUSTRATED EXPERIENCE - Real pain points
  frustratedReality: [
    "I need to fill in 7 different boxes with variation of the same information to create a task that took me 10 minutes to complete",
    "Yes, took, because I already fucking completed it, but it is a god damn requirement that I capture it",
    "You inevitably end up with someone high up in management whose sole job is customizing jira and making devs lives worse",
    "That literally flies in the face of every developer I've ever spoken to in 10 years of software development",
    "its shite, but its the best of the shite",
    "Most people just hate having to do tickets, but that's a bureaucratic office problem",
    "tools like JIRA or Slack are great as products, but are terrible because of who they are aimed at"
  ],

  // CONVERSATIONAL CHAOS - Real human threads
  conversationalFlow: [
    "I suspect you both are right.",
    "Have you USED anything else?",
    "This is the correct answer as a solo and team dev",
    "Another user explained it well but basically",
    "Oddly enough, from the issue trackers",
    "I don't know of any 'gosh I wished we used X instead of Jira products', do you?",
    "You know what's worse than tickets? 10 engineers and 5 PMs and ProjMs with all different to do lists"
  ],

  // MEME ENERGY - Pop culture chaos
  memeReferences: [
    "2 Face 2 book: Tokyo drift",
    "Drop the 'new'. Just thefacebook. It's cleaner.",
    "money printer go brrr",
    "Zuckerberg better watch his back, we comin'!",
    "Can't get rich on an empty pump, you feel me?",
    "I only travel by dildo shaped rockets from my own rocket company now",
    "....and that's how monday.com was created. Next up: how freshdesk was invented."
  ],

  // SPECIFIC EXPERIENCES - Real human stories
  specificExperiences: [
    "Used Jira for so many years and linear simply does everything better, except for docs",
    "I've been doing dotnet development since dotnet was invented 20 years ago",
    "Over 50 here and I'm ready for a Facebook level tech screen",
    "my KPIs are tied to the reporting generated by this system. So if you don't report that you did something. I don't get my bonus",
    "I'm not a FANG engineer but I got to the last round of a few interviews",
    "The millions saved in tax credits are used to justify the cost of hiring people in the first place"
  ],

  // ERROR CHAOS - Development pain
  errorChaos: [
    "Found 143 errors, fixing… 2 hours of pressing 'yes' later… Good progress! Only 178 errors left!",
    "FATAL ERROR: Incompatible peer dependencies found",
    "error 147 more dependency conflicts... Build failed.",
    "The production environment is currently serving a FATAL ERROR screen",
    "you ran out of tokens",
    "I said NO errors 🤬"
  ],

  // PHILOSOPHICAL DEPTH - Unexpected wisdom
  unexpectedWisdom: [
    "Scale, reporting, finance, regulatory requirements, staffing, forecasting, coordinating, and generally tying shit together all create challenges",
    "Most reporting is tied to egos. It's a cascading effect that multiplies with scale",
    "Transparency becomes useless tediousness",
    "These numbers are up 1.09% compared to last year. Let's call it a win",
    "the issue is you have garbage people in middle management often"
  ]
};

// CHAOS PERSONALITY TYPES - Real Reddit archetypes
const chaosPersonalities = {
  oneWordReactor: {
    style: "minimal, impactful responses",
    patterns: redditChaosPatterns.oneWordWonders,
    probability: 0.15
  },
  
  technicalAbsurdist: {
    style: "overengineered technical solutions with humor",
    patterns: redditChaosPatterns.technicalAbsurdity,
    probability: 0.12
  },
  
  frustratedVeteran: {
    style: "years of pain compressed into raw truth",
    patterns: redditChaosPatterns.frustratedReality,
    probability: 0.18
  },
  
  conversationBuilder: {
    style: "references others, builds threads naturally",
    patterns: redditChaosPatterns.conversationalFlow,
    probability: 0.20
  },
  
  memeGod: {
    style: "pop culture references and internet culture",
    patterns: redditChaosPatterns.memeReferences,
    probability: 0.10
  },
  
  storyTeller: {
    style: "specific personal experiences and anecdotes",
    patterns: redditChaosPatterns.specificExperiences,
    probability: 0.15
  },
  
  errorSufferer: {
    style: "development pain and debugging hell",
    patterns: redditChaosPatterns.errorChaos,
    probability: 0.08
  },
  
  unexpectedPhilosopher: {
    style: "drops unexpected wisdom bombs",
    patterns: redditChaosPatterns.unexpectedWisdom,
    probability: 0.02
  }
};

// PURE CHAOS COMMENT GENERATION
function generatePureChaosComment(post, personalityType) {
  const personality = chaosPersonalities[personalityType];
  const pattern = personality.patterns[Math.floor(Math.random() * personality.patterns.length)];
  
  // Analyze post for specific hooks
  const postContent = `${post.title} ${post.description}`.toLowerCase();
  
  // CONTEXTUAL CHAOS - Make it relevant to the post
  let comment = pattern;
  
  // Add post-specific chaos based on content
  if (postContent.includes('instagram')) {
    comment = adaptToInstagram(comment, postContent);
  } else if (postContent.includes('twitter') || postContent.includes(' x ')) {
    comment = adaptToTwitter(comment, postContent);
  } else if (postContent.includes('ai') || postContent.includes('automation')) {
    comment = adaptToAI(comment, postContent);
  } else if (postContent.includes('revenue') || postContent.includes('monetiz')) {
    comment = adaptToRevenue(comment, postContent);
  }
  
  // Apply PURE Reddit chaos modifiers
  comment = applyRedditChaos(comment, personalityType);
  
  return comment;
}

// CONTEXTUAL ADAPTATION FUNCTIONS
function adaptToInstagram(baseComment, postContent) {
  const instagramChaos = [
    "algorithm fucked everyone on insta",
    "shadowban hell is real", 
    "engagement pods are dead",
    "reels killed everything",
    "stories > feed now",
    "influencer bubble popped"
  ];
  
  if (Math.random() < 0.3) {
    const chaos = instagramChaos[Math.floor(Math.random() * instagramChaos.length)];
    return `${baseComment}. ${chaos}`;
  }
  
  return baseComment;
}

function adaptToTwitter(baseComment, postContent) {
  const twitterChaos = [
    "elon broke everything",
    "X is just twitter with more bugs",
    "blue check system is chaos",
    "reach is dead unless you pay",
    "API costs killed all the good bots",
    "rate limits everywhere"
  ];
  
  if (Math.random() < 0.3) {
    const chaos = twitterChaos[Math.floor(Math.random() * twitterChaos.length)];
    return `${baseComment}. ${chaos}`;
  }
  
  return baseComment;
}

function adaptToAI(baseComment, postContent) {
  const aiChaos = [
    "gpt4 vs claude is like iphone vs android flame wars",
    "prompt engineering is just fancy googling",
    "everyone thinks theyre an ai expert now",
    "chatgpt university graduates everywhere",
    "ai will replace X posts are getting old",
    "most ai startups are just wrappers"
  ];
  
  if (Math.random() < 0.3) {
    const chaos = aiChaos[Math.floor(Math.random() * aiChaos.length)];
    return `${baseComment}. ${chaos}`;
  }
  
  return baseComment;
}

function adaptToRevenue(baseComment, postContent) {
  const revenueChaos = [
    "another 'how i made 10k' post",
    "results not typical disclaimers needed",
    "survivorship bias much?",
    "passive income that requires 80 hours a week",
    "affiliate links hidden everywhere",
    "course selling courses inception"
  ];
  
  if (Math.random() < 0.3) {
    const chaos = revenueChaos[Math.floor(Math.random() * revenueChaos.length)];
    return `${baseComment}. ${chaos}`;
  }
  
  return baseComment;
}

// PURE REDDIT CHAOS MODIFIERS
function applyRedditChaos(comment, personalityType) {
  // Random lowercase chaos
  if (Math.random() < 0.7) {
    comment = comment.toLowerCase();
  }
  
  // Random punctuation chaos
  if (Math.random() < 0.4) {
    comment = comment.replace(/\.$/, '');
  }
  
  // Add random reddit-style additions
  if (Math.random() < 0.15) {
    const additions = [
      " tbh",
      " ngl", 
      " fr",
      " lol",
      " smh",
      " imo",
      " 🤷‍♂️",
      " 😅",
      " 💀"
    ];
    comment += additions[Math.floor(Math.random() * additions.length)];
  }
  
  // Random typos for authenticity
  if (Math.random() < 0.1) {
    const typos = {
      'your': 'youre',
      'there': 'thier', 
      'definitely': 'definately',
      'separate': 'seperate'
    };
    
    for (const [correct, typo] of Object.entries(typos)) {
      if (comment.includes(correct) && Math.random() < 0.5) {
        comment = comment.replace(correct, typo);
        break;
      }
    }
  }
  
  return comment;
}

// PURE CHAOS REPLY GENERATION
function generateChaosReply(originalComment, personalityType) {
  const replyTypes = [
    "This.",
    "Exactly this.",
    "came here to say this",
    "underrated comment",
    "why is this downvoted",
    "someone give this gold",
    "facts",
    "100%",
    "big mood",
    "felt this",
    "hard agree",
    "^ this guy gets it",
    "you win the internet today",
    "take my upvote",
    "username checks out"
  ];
  
  if (Math.random() < 0.6) {
    return replyTypes[Math.floor(Math.random() * replyTypes.length)];
  }
  
  // Longer conversational replies
  const conversationalReplies = [
    "wait what? how does that even work",
    "ok but have you actually tried this though",
    "source? asking for a friend",
    "instructions unclear, ended up with 500 errors",
    "tried this, can confirm it works",
    "your mileage may vary but worked for me",
    "bold of you to assume i have time for this",
    "laughs in enterprise software",
    "cries in technical debt"
  ];
  
  return conversationalReplies[Math.floor(Math.random() * conversationalReplies.length)];
}

// CHAOS COMMENT GENERATION FOR POST
function generateChaosCommentsForPost(post) {
  const postDate = new Date(post.date);
  const now = new Date();
  const daysSincePublish = Math.floor((now.getTime() - postDate.getTime()) / (1000 * 60 * 60 * 24));
  
  // Age-based comment count with more chaos
  let baseComments = Math.floor(Math.random() * 8) + 2; // 2-10 base
  if (daysSincePublish > 60) baseComments += Math.floor(Math.random() * 15);
  else if (daysSincePublish > 30) baseComments += Math.floor(Math.random() * 8);
  else if (daysSincePublish > 14) baseComments += Math.floor(Math.random() * 5);
  
  const comments = [];
  
  // Generate pure chaos comments
  for (let i = 0; i < baseComments; i++) {
    // Select personality type based on probability
    let selectedPersonality = null;
    const rand = Math.random();
    let cumulative = 0;
    
    for (const [type, config] of Object.entries(chaosPersonalities)) {
      cumulative += config.probability;
      if (rand <= cumulative) {
        selectedPersonality = type;
        break;
      }
    }
    
    const comment = {
      id: Math.random().toString(36).substr(2, 9),
      username: 'Guest',
      avatar: '',
      content: generatePureChaosComment(post, selectedPersonality),
      timestamp: generateTimestamp(Math.floor(Math.random() * daysSincePublish)),
      likes: Math.floor(Math.random() * 100) + 1,
      replies: [],
      isOP: false
    };
    
    // 30% chance of replies with pure chaos
    if (Math.random() < 0.3) {
      const replyCount = Math.floor(Math.random() * 4) + 1;
      for (let j = 0; j < replyCount; j++) {
        const replyPersonality = Object.keys(chaosPersonalities)[Math.floor(Math.random() * Object.keys(chaosPersonalities).length)];
        const reply = {
          id: Math.random().toString(36).substr(2, 9),
          username: 'Guest',
          avatar: '',
          content: generateChaosReply(comment.content, replyPersonality),
          timestamp: generateTimestamp(Math.floor(Math.random() * 7)),
          likes: Math.floor(Math.random() * 25) + 1,
          replies: [],
          isOP: false
        };
        comment.replies.push(reply);
      }
    }
    
    comments.push(comment);
  }
  
  return {
    postSlug: post.slug,
    comments,
    commentCount: comments.length + comments.reduce((sum, c) => sum + c.replies.length, 0)
  };
}

// Generate realistic timestamp
function generateTimestamp(daysAgo = null) {
  const now = new Date();
  const randomDays = daysAgo || Math.floor(Math.random() * 30);
  const randomHours = Math.floor(Math.random() * 24);
  const randomMinutes = Math.floor(Math.random() * 60);
  
  const timestamp = new Date(now);
  timestamp.setDate(timestamp.getDate() - randomDays);
  timestamp.setHours(timestamp.getHours() - randomHours);
  timestamp.setMinutes(timestamp.getMinutes() - randomMinutes);
  
  return timestamp.toISOString();
}

// Get blog posts
function getBlogPosts() {
  const dataPath = path.join(__dirname, '../src/data/blog-posts.ts');
  const content = fs.readFileSync(dataPath, 'utf8');
  
  const jsonMatch = content.match(/export const allBlogPosts: BlogPost\[\] = (.*?);/s);
  if (!jsonMatch) {
    throw new Error('Could not extract blog posts data');
  }
  
  return JSON.parse(jsonMatch[1]);
}

// MAIN CHAOS GENERATOR
async function generateTrueRedditChaos() {
  console.log('🌪️ UNLEASHING TRUE REDDIT CHAOS...');
  console.log('🎭 No templates, no patterns, just pure human authenticity');
  
  const blogPosts = getBlogPosts();
  const allComments = {};
  
  // Process posts with pure chaos
  const batchSize = 10;
  for (let i = 0; i < blogPosts.length; i += batchSize) {
    const batch = blogPosts.slice(i, i + batchSize);
    
    console.log(`🎪 Processing chaos batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(blogPosts.length / batchSize)}...`);
    
    for (const post of batch) {
      const postComments = generateChaosCommentsForPost(post);
      allComments[post.slug] = postComments;
      
      console.log(`   🎭 Generated ${postComments.commentCount} PURE CHAOS comments for "${post.title}"`);
    }
    
    await new Promise(resolve => setTimeout(resolve, 50));
  }
  
  // Write true chaos comments
  const outputContent = `// TRUE REDDIT CHAOS - Pure human authenticity captured from real conversations
// Generated on: ${new Date().toISOString()}
// Features: No templates, no patterns, just pure chaotic human communication
// Based on: Real Reddit r/ClaudeAI conversations with all their beautiful imperfections

export interface Comment {
  id: string;
  username: string;
  avatar: string;
  content: string;
  timestamp: string;
  likes: number;
  replies: Comment[];
  isOP?: boolean;
}

export interface PostComments {
  postSlug: string;
  comments: Comment[];
  commentCount: number;
}

export const blogComments: Record<string, PostComments> = ${JSON.stringify(allComments, null, 2)};

// Helper function to get comments for a specific post
export function getCommentsForPost(slug: string): PostComments | null {
  return blogComments[slug] || null;
}
`;
  
  const outputPath = path.join(__dirname, '../src/data/blog-comments.ts');
  fs.writeFileSync(outputPath, outputContent);
  
  console.log(`\n🎉 TRUE REDDIT CHAOS UNLEASHED!`);
  console.log(`📁 Output: ${outputPath}`);
  
  // Statistics
  const totalComments = Object.values(allComments).reduce((sum, post) => sum + post.commentCount, 0);
  const avgCommentsPerPost = Math.round(totalComments / blogPosts.length);
  
  console.log(`📊 CHAOS Statistics:`);
  console.log(`   Total comments: ${totalComments}`);
  console.log(`   Average per post: ${avgCommentsPerPost}`);
  console.log(`   Personality types: ${Object.keys(chaosPersonalities).length}`);
  console.log(`   Authenticity level: PURE REDDIT CHAOS`);
  console.log(`   🎭 One-word reactions: ${redditChaosPatterns.oneWordWonders.length}`);
  console.log(`   🤖 Technical absurdity: ${redditChaosPatterns.technicalAbsurdity.length}`);
  console.log(`   😤 Frustrated reality: ${redditChaosPatterns.frustratedReality.length}`);
  console.log(`   🧠 Unexpected wisdom: ${redditChaosPatterns.unexpectedWisdom.length}`);
}

// Run the chaos generator
if (require.main === module) {
  generateTrueRedditChaos().catch(console.error);
}

module.exports = { generateTrueRedditChaos };